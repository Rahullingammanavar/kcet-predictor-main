<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KCET College Predictor — Interview Notes</title>
  <style>
    :root{--accent:#0b66c3;--muted:#666}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;line-height:1.5;color:#111;background:#f7f9fb;padding:24px}
    .container{max-width:900px;margin:0 auto;background:#fff;padding:28px;border-radius:12px;box-shadow:0 6px 20px rgba(12,18,30,0.06)}
    h1{margin:0 0 8px;font-size:22px}
    .pitch{background:linear-gradient(90deg,#eaf4ff, #fff);border-left:4px solid var(--accent);padding:14px 16px;border-radius:8px;margin-bottom:18px}
    .meta{color:var(--muted);font-size:13px;margin-bottom:18px}
    section{margin-bottom:18px}
    h2{font-size:16px;margin:0 0 8px}
    pre {background:#0f1724;color:#e6f2ff;padding:12px;border-radius:8px;overflow:auto}
    code{background:#f3f6f9;padding:2px 6px;border-radius:6px}
    table{width:100%;border-collapse:collapse;margin-top:8px}
    td,th{padding:8px;border:1px solid #eee;text-align:left}
    .btns{display:flex;gap:8px;margin-top:10px}
    a.button{display:inline-block;padding:8px 12px;border-radius:8px;background:var(--accent);color:#fff;text-decoration:none}
    footer{color:var(--muted);font-size:13px;margin-top:18px}
    .highlight{background:#f1f9ff;border-left:3px solid #bfe0ff;padding:10px;border-radius:6px}
  </style>
</head>
<body>
  <div class="container">
    <h1>KCET College Predictor — Interview Notes</h1>
    <div class="pitch">
      <strong>30-Second Elevator Pitch</strong>
      <p style="margin:10px 0 0">“I worked on a KCET College Predictor web app built with Flask and SQLite. It lets students input their KCET rank and category to see eligible colleges. I handled CSV-to-database conversion using Pandas, implemented SQL queries for rank filtering, and generated downloadable PDF reports. One main challenge was handling data type mismatches during import, which I solved through preprocessing. The project helped me understand backend routing, database handling, and deployment using Vercel.”</p>
    </div>

    <div class="meta">Quick revision notes focused on interview questions — memorize the pitch and use the sections below to expand answers.</div>

    <section>
      <h2>Inspiration & Impact</h2>
      <div class="highlight">
        <p><strong>Inspiration:</strong> While preparing for KCET counseling, I found it difficult to quickly identify which colleges I could realistically get into for different categories and rounds. That friction inspired the idea for this project — to make rank-to-college lookup fast and user-friendly.</p>
        <p><strong>Impact:</strong> The app has seen real usage — <strong>1,000+ users in the last 3–4 months</strong> using it to check their expected colleges and download reports. This shows it solved a genuine user pain point.</p>
      </div>
    </section>

    <section>
      <h2>Project Summary</h2>
      <p>Predict eligible engineering colleges based on KCET exam rank, category, and counseling round.</p>
      <p><strong>Tech stack:</strong> Flask, SQLite, SQLAlchemy, Pandas, NumPy, FPDF, Vercel.</p>
      <p><strong>Live app:</strong> <a href="https://kcet-predictor.vercel.app/" target="_blank">https://kcet-predictor.vercel.app/</a></p>
    </section>

    <section>
      <h2>Role & Contributions</h2>
      <ul>
        <li>Implemented Flask backend routes for querying and PDF generation.</li>
        <li>Automated CSV → SQLite conversion using Pandas and handled missing values/type conversions.</li>
        <li>Designed SQL logic for rank-based filtering and formatted user-facing PDF reports.</li>
        <li>Deployed the app on Vercel with a custom <code>vercel.json</code> configuration.</li>
      </ul>
    </section>

    <section>
      <h2>How it Works (Simple Flow)</h2>
      <pre>CSV (cutoffs)  → csvtodb.py → cutoffs.db
       ↓
     User enters (category, rank range, round)
       ↓
     Flask (app.py) → SQL query → JSON response or PDF</pre>
    </section>

    <section>
      <h2>Key Files & Purpose</h2>
      <table>
        <tr><th>File</th><th>Purpose</th></tr>
        <tr><td>app.py</td><td>Main Flask app: routes, SQL queries, PDF download</td></tr>
        <tr><td>csvtodb (1).py</td><td>Convert CSV cutoff data to SQLite database</td></tr>
        <tr><td>pdf_handler.py</td><td>Generates formatted PDF reports (FPDF)</td></tr>
        <tr><td>vercel.json</td><td>Vercel deployment config</td></tr>
        <tr><td>requirements.txt</td><td>Dependencies</td></tr>
      </table>
    </section>

    <section>
      <h2>Database & Query Logic (Short)</h2>
      <p><strong>CSV→DB:</strong> pandas reads CSV, replaces <code>"--"</code> with <code>NaN</code>, converts numeric columns, then <code>df.to_sql()</code> writes to SQLite.</p>
      <p><strong>Query example (app.py):</strong></p>
      <pre>SELECT BRANCH, GM, COLLEGES FROM '2024r3' WHERE GM BETWEEN 1000 AND 4000 ORDER BY GM ASC;</pre>
    </section>

    <section>
      <h2>Common Interview Qs & Short Answers</h2>
      <table>
        <tr><th>Question</th><th>Short Answer</th></tr>
        <tr><td>What is the project?</td><td>Web app to predict eligible colleges based on KCET rank and category.</td></tr>
        <tr><td>How did you store data?</td><td>Converted CSV to SQLite using Pandas and <code>to_sql()</code>.</td></tr>
        <tr><td>How does backend work?</td><td>Flask routes accept input, run an SQL query, return JSON or a PDF.</td></tr>
        <tr><td>Main challenge?</td><td>Data type mismatches during import; fixed via preprocessing and nullable integer types.</td></tr>
      </table>
    </section>

    <section>
      <h2>Why these technologies? (Short explanations)</h2>
      <ul>
        <li><strong>Why Flask?</strong> Lightweight, easy to set up, excellent for small-to-medium web apps and prototyping. It maps well to simple route-based logic like `/submit` and `/generate-pdf`.</li>
        <li><strong>Why SQLite?</strong> File-based, zero-config database that's perfect for small projects and demos. Easy to create with `pandas.to_sql()` and has low operational overhead compared to running a separate DB server.</li>
        <li><strong>Why Vercel?</strong> Fast deployment with serverless functions and straightforward routing via <code>vercel.json</code>. Good for quickly shipping a Python-backed frontend without managing servers.</li>
        <li><strong>Why Pandas?</strong> Powerful and concise for CSV cleaning, transformation, and quick export to SQL.</li>
        <li><strong>Why FPDF?</strong> Simple and reliable for generating programmatic PDF reports without heavy dependencies.</li>
      </ul>
    </section>

    <section>
      <h2>Potential Interview Questions (and how to answer)</h2>
      <ol>
        <li><strong>How do you validate user input?</strong>
          <div>Answer: Validate on the frontend for basic format (numbers present, ranges sane) and always re-validate on backend. In `app.py` check that <code>lrank</code> and <code>urank</code> are integers, <code>cat</code> is an allowed column name, and <code>round</code> matches existing table names before building SQL.</div>
        </li>
        <li><strong>How would you prevent SQL injection?</strong>
          <div>Answer: Avoid directly interpolating user input into SQL. Use parameterized queries where possible, whitelist allowed column names and table names, and use SQLAlchemy's <code>text()</code> with bound parameters. Also validate and sanitize all inputs.</div>
        </li>
        <li><strong>Why not use a heavier framework like Django?</strong>
          <div>Answer: For this use-case (simple routing, lightweight DB access, minimal ORM work), Flask is faster to develop and keep simple. Django is great for large projects with built-in admin, auth, and ORM-heavy apps — but that would be overkill here.</div>
        </li>
        <li><strong>How will you scale if traffic increases?</strong>
          <div>Answer: Move DB to a managed SQL server (Postgres), use connection pooling, add caching (Redis) for common queries, put the app behind a load balancer and scale instances, and move static assets to a CDN.</div>
        </li>
        <li><strong>How do you handle long college names in the PDF?</strong>
          <div>Answer: Use FPDF's <code>multi_cell()</code> to wrap text and set appropriate column widths. For very long content consider truncation with ellipsis or adding a separate details page.</div>
        </li>
        <li><strong>How do you monitor or track usage?</strong>
          <div>Answer: Basic logging in Flask (IP + geo lookup via ip-api) is implemented. For production add analytics (Google Analytics / Matomo), logging aggregation (ELK/CloudWatch), and performance monitoring (New Relic / Prometheus).</div>
        </li>
        <li><strong>What if the CSV schema changes?</strong>
          <div>Answer: Build a schema validation step in the CSV importer that checks column names/types and provides clear errors. Use versioned database tables (e.g., 2024r3) and migration scripts.</div>
        </li>
        <li><strong>How to add authentication?</strong>
          <div>Answer: Add user accounts with OAuth or JWT-based auth, secure endpoints, and restrict report downloads. Use HTTPS everywhere and store sensitive data securely.</div>
        </li>
        <li><strong>Why not use a client-side search?</strong>
          <div>Answer: Client-side search requires loading entire DB into the browser which is inefficient for large datasets. Server-side SQL queries allow filtering and pagination efficiently on the server.</div>
        </li>
        <li><strong>How are missing values handled?</strong>
          <div>Answer: Missing values marked as "--" are converted to <code>NaN</code> and stored as nullable integers using <code>pd.Int64Dtype()</code>. Queries can then ignore or handle NULLs appropriately.</div>
        </li>
      </ol>
    </section>

    <section>
      <h2>Challenges & Learnings (Quick Lines)</h2>
      <ul>
        <li><strong>Data cleaning:</strong> Replaced missing markers and standardized types before DB insertion.</li>
        <li><strong>PDF formatting:</strong> Used <code>multi_cell()</code> to wrap long names.</li>
        <li><strong>HTTP & ports:</strong> Learned GET/POST and that Flask listens on port 5000 locally; Vercel handles production ports.</li>
        <li><strong>Deployment:</strong> Configured <code>vercel.json</code> to route traffic to <code>app.py</code>.</li>
      </ul>
    </section>

    <section>
      <h2>Resume Summary (2 lines)</h2>
      <p><strong>KCET College Predictor</strong> — Built a Flask-based web tool to predict engineering college admissions using KCET ranks. Implemented CSV-to-database pipeline, SQL-based filtering, and PDF report generation; deployed on Vercel. Mentioned inspiration: built to solve my own difficulty during KCET counseling; 1,000+ users in 3–4 months.</p>
    </section>

    <section>
      <h2>Memorize These (Top lines for quick recall)</h2>
      <ol>
        <li>Elevator pitch (top of page)</li>
        <li>One-sentence role & tech stack</li>
        <li>Main challenge and how you solved it</li>
        <li>Impact statement: "1,000+ users in 3–4 months"</li>
      </ol>
    </section>

    <div class="btns">
      <a class="button" href="#download" onclick="downloadFile()">Download HTML</a>
      <a class="button" href="https://kcet-predictor.vercel.app/" target="_blank">Open Live App</a>
    </div>

    <footer>
      Generated for interview prep — feel free to ask to add/remove sections or export as PDF/DOCX.
    </footer>
  </div>

  <script>
    function downloadFile(){
      const blob = new Blob([document.documentElement.outerHTML], {type: 'text/html'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'KCET_Project_Interview_Notes.html'; document.body.appendChild(a);
      a.click(); a.remove(); URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>